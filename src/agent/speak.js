import { exec, spawn } from 'child_process';
import { sendAudioRequest } from '../models/pollinations.js';
import textToSpeech from '@google-cloud/text-to-speech';
import { EventEmitter } from 'events';
import { createRobotController } from '../utils/robot_controller.js';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';import { exec, spawn } from 'child_process';
import { sendAudioRequest } from '../models/pollinations.js';
import textToSpeech from '@google-cloud/text-to-speech';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
import { EventEmitter } from 'events';
import { createRobotController } from '../utils/robot_controller.js';
import fs from 'fs';

// ‚úÖ Ï§ëÎ≥µ import Ï†úÍ±∞Îê®

export const ttsEvents = new EventEmitter();

let speakingQueue = [];
let isSpeaking = false;

// ‚úÖ Google TTS ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î•º Ï†ÑÏó≠ÏúºÎ°ú Ìïú Î≤àÎßå ÏÉùÏÑ±
let googleTTSClient = null;

function getGoogleTTSClient() {
  if (!googleTTSClient) {
    try {
      const credentialsPath = path.resolve(process.cwd(), 'google-credentials.json');
      
      // ÌååÏùº Ï°¥Ïû¨ ÌôïÏù∏
      if (fs.existsSync(credentialsPath)) {
        console.log(`‚úÖ [Google TTS] Loading credentials from: ${credentialsPath}`);
        googleTTSClient = new textToSpeech.TextToSpeechClient({
          keyFilename: credentialsPath
        });
      } else {
        console.warn(`‚ö†Ô∏è [Google TTS] Credentials file not found at: ${credentialsPath}`);
        console.warn(`‚ö†Ô∏è [Google TTS] Falling back to default credentials (environment variable)`);
        googleTTSClient = new textToSpeech.TextToSpeechClient();
      }
    } catch (error) {
      console.error(`‚ùå [Google TTS] Failed to initialize client:`, error.message);
      throw error;
    }
  }
  return googleTTSClient;
}

// --- Î°úÎ¥á Ïª®Ìä∏Î°§Îü¨ Ïù∏Ïä§ÌÑ¥Ïä§ Í¥ÄÎ¶¨ (speak.jsÏóêÏÑú ÏßÅÏ†ë) ---
let robotController = null;
let robotInitialized = false;

async function initRobotController() {
  if (robotInitialized) return robotController;
  
  robotInitialized = true;
  
  try {
    robotController = createRobotController({ 
      debug: true,
      timeoutMs: 600,
      retries: 1 
    });
    
    // Ìó¨Ïä§Ï≤¥ÌÅ¨Î°ú Ïó∞Í≤∞ ÌôïÏù∏
    const health = await robotController.healthCheck();
    if (health.online) {
      console.log(`ü§ñ [TTS] Robot controller connected (latency: ${health.latency}ms)`);
      return robotController;
    } else {
      console.warn(`ü§ñ [TTS] Robot controller offline: ${health.error || 'unknown error'}`);
      robotController = null;
      return null;
    }
  } catch (error) {
    console.warn(`ü§ñ [TTS] Failed to initialize robot controller:`, error.message);
    robotController = null;
    return null;
  }
}

// --- Î°úÎ¥á LED Ï†úÏñ¥ Ìï®ÏàòÎì§ ---
async function safeSpeechStart() {
  try {
    const robot = robotController || await initRobotController();
    if (robot?.onSpeechStart) {
      await robot.onSpeechStart();
      console.log(`üé§ [TTS] Speech started - robot blink ON`);
    }
  } catch (e) { 
    console.warn('[TTS] onSpeechStart failed:', e?.message || e); 
  }
}

async function safeSpeechEnd() {
  try {
    const robot = robotController || await initRobotController();
    if (robot?.onSpeechEnd) {
      await robot.onSpeechEnd();
      console.log(`üé§ [TTS] Speech ended - robot blink OFF`);
    }
  } catch (e) { 
    console.warn('[TTS] onSpeechEnd failed:', e?.message || e); 
  }
}

/**
 * Google Cloud TTS Ìï®Ïàò
 * @param {string} text - ÎßêÌï† ÌÖçÏä§Ìä∏
 * @param {string} voice - Î™©ÏÜåÎ¶¨ (ko-KR-Neural2-A, ko-KR-Neural2-B, ko-KR-Neural2-C)
 * @param {string} languageCode - Ïñ∏Ïñ¥ ÏΩîÎìú (ko-KR, en-US Îì±)
 * @returns {Promise<Buffer>} - MP3 Ïò§ÎîîÏò§ Îç∞Ïù¥ÌÑ∞
 */
async function sendGoogleTTS(text, voice = 'ko-KR-Neural2-A', languageCode = 'ko-KR') {
  try {
    const client = getGoogleTTSClient(); // ‚úÖ ÏàòÏ†ï: Ï†ÑÏó≠ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÇ¨Ïö©
    
    console.log(`üé§ [Google TTS] Generating speech (voice: ${voice}, language: ${languageCode})`);
    
    const request = {
      input: { text: text },
      voice: {
        languageCode: languageCode,
        name: voice,
        ssmlGender: voice.includes('-A') || voice.includes('-B') ? 'FEMALE' : 'MALE'
      },
      audioConfig: {
        audioEncoding: 'MP3',
        speakingRate: 1.0,  // ÏÜçÎèÑ (0.25 ~ 4.0)
        pitch: 0.0,         // ÏùåÎÜíÏù¥ (-20.0 ~ 20.0)
        volumeGainDb: 0.0   // Î≥ºÎ•® (-96.0 ~ 16.0)
      },
    };

    const [response] = await client.synthesizeSpeech(request);
    const audioBuffer = Buffer.from(response.audioContent);
    
    console.log(`‚úÖ [Google TTS] Generated ${audioBuffer.length} bytes`);
    return audioBuffer;
    
  } catch (err) {
    console.error('[Google TTS] Error:', err.message);
    throw err;
  }
}

/**
 * Text-to-Speech with queue.
 * Keeps API compat with previous usage but now returns a Promise that resolves when playback finishes.
 * @param {string} text
 * @param {string|object} speak_model e.g. 'google/ko-KR-Neural2-A' or 'pollinations/openai-audio/echo'
 * @returns {Promise<void>}
 */
export function say(text, speak_model) {
  return new Promise((resolve, reject) => {
    speakingQueue.push({ text, speak_model, resolve, reject });
    if (!isSpeaking) processQueue();
  });
}

async function processQueue() {
  if (speakingQueue.length === 0) {
    isSpeaking = false;
    // ‚úÖ TTS Ï¢ÖÎ£å ÏïåÎ¶º (STT Ïû¨Í∞ú Í∞ÄÎä•)
    global.isTTSPlaying = false;
    ttsEvents.emit('speaking-ended');
    return;
  }
  isSpeaking = true;
  
  // ‚úÖ TTS ÏãúÏûë ÏïåÎ¶º (STT ÏùºÏãúÏ†ïÏßÄ)
  global.isTTSPlaying = true;
  ttsEvents.emit('speaking-started');

  const job = speakingQueue.shift();
  const txt = job.text;
  const speak_model = job.speak_model;
  const resolve = job.resolve;
  const reject = job.reject;

  const isWin = process.platform === 'win32';
  const isMac = process.platform === 'darwin';
  const model = speak_model || 'google/ko-KR-Neural2-A';

  // Í≥µÌÜµ: ÏãúÏûë Ïù¥Î≤§Ìä∏/LED
  try { ttsEvents.emit('start', { text: txt, model }); } catch {}
  await safeSpeechStart();

  const finishOk = async () => {
    try { ttsEvents.emit('end', { text: txt, model }); } catch {}
    await safeSpeechEnd();
    resolve?.();
    processQueue();
  };
  const finishErr = async (err) => {
    try { ttsEvents.emit('error', err); } catch {}
    await safeSpeechEnd();
    reject?.(err);
    processQueue();
  };

  if (model === 'system') {
    // --- System TTS (Windows/macOS/Linux) ---
    const cmd = isWin
      ? `powershell -NoProfile -Command "Add-Type -AssemblyName System.Speech; `
        + `$s=New-Object System.Speech.Synthesis.SpeechSynthesizer; $s.Rate=2; `
        + `$s.Speak('${txt.replace(/'/g,"''")}'); $s.Dispose()"`
      : isMac
      ? `say "${txt.replace(/"/g,'\\"')}"`
      : `espeak "${txt.replace(/"/g,'\\"')}"`;

    exec(cmd, async (err) => {
      if (err) {
        console.error('TTS error', err);
        await finishErr(err);
      } else {
        await finishOk();
      }
    });

  } else {
    // --- Parse model string ---
    let prov, voice, languageCode, url;
    if (typeof model === "string") {
      const parts = model.split('/');
      prov = parts[0];
      voice = parts[1];
      languageCode = parts[2] || (voice ? voice.split('-').slice(0, 2).join('-') : 'ko-KR');
    } else {
      prov = model.api;
      voice = model.voice;
      languageCode = model.languageCode || 'ko-KR';
      url = model.url;
    }

    // --- Google Cloud TTS ---
    if (prov === 'google') {
      try {
        const audioBuffer = await sendGoogleTTS(txt, voice, languageCode);
        
        // ‚úÖ WindowsÎèÑ ffplay ÏÇ¨Ïö© (Îçî ÏïàÏ†ïÏ†Å)
        const tempFile = path.join(__dirname, `tts_temp_${Date.now()}.mp3`);
        
        try {
          fs.writeFileSync(tempFile, audioBuffer);
          
          const player = spawn('ffplay', [
            '-nodisp',      // Ï∞Ω Ïïà ÎùÑÏö∞Í∏∞
            '-autoexit',    // Ïû¨ÏÉù ÎÅùÎÇòÎ©¥ ÏûêÎèô Ï¢ÖÎ£å
            '-loglevel', 'quiet',  // Î°úÍ∑∏ Ïà®Í∏∞Í∏∞
            tempFile
          ], {
            stdio: 'ignore'
          });
          
          player.on('exit', async (code) => { 
            try { fs.unlinkSync(tempFile); } catch {}
            if (code === 0) await finishOk();
            else await finishErr(new Error(`ffplay exit ${code}`));
          });
          
          player.on('error', async (e) => { 
            console.error('[TTS] ffplay error:', e.message);
            try { fs.unlinkSync(tempFile); } catch {}
            await finishErr(e); 
          });
          
        } catch (e) {
          try { fs.unlinkSync(tempFile); } catch {}
          await finishErr(e);
        }

      } catch (e) {
        console.error('Google TTS error', e);
        await finishErr(e);
      }

    // --- Pollinations TTS ---
    } else if (prov === 'pollinations') {
      url = url || "https://text.pollinations.ai/openai";
      
      try {
        let audioData = await sendAudioRequest(txt, voice, null, url);
        if (!audioData) {
          audioData = "SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU5LjI3LjEwMAAAAAAAAAAAAAAA/+NAwAAAAAAAAAAAAEluZm8AAAAPAAAAAAAAANAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAExhdmM1OS4zNwAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAeowAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==";
        }

        if (isWin) {
          const ps = `
            Add-Type -AssemblyName presentationCore;
            $p=New-Object System.Windows.Media.MediaPlayer;
            $p.Open([Uri]::new("data:audio/mp3;base64,${audioData}"));
            $p.Play();
            Start-Sleep -Seconds [math]::Ceiling($p.NaturalDuration.TimeSpan.TotalSeconds);
          `;
          const psProcess = spawn('powershell', ['-NoProfile','-Command', ps], {
            stdio: 'ignore', detached: true
          });
          psProcess.on('exit', async () => { await finishOk(); });

        } else {
          const player = spawn('ffplay', ['-nodisp','-autoexit','pipe:0'], {
            stdio: ['pipe','ignore','ignore']
          });
          player.stdin.write(Buffer.from(audioData, 'base64'));
          player.stdin.end();
          player.on('exit', async (code) => { 
            if (code === 0) await finishOk(); 
            else await finishErr(new Error(`ffplay exit ${code}`));
          });
          player.on('error', async (e) => { 
            console.error('ffplay spawn error', e); 
            await finishErr(e); 
          });
        }

      } catch (e) {
        console.error('Pollinations TTS error', e);
        await finishErr(e);
      }

    } else {
      await finishErr(new Error(`Unknown TTS provider: ${prov}`));
    }
  }
}

// --- ÏàòÎèô Î°úÎ¥á Ï†úÏñ¥ Ìï®ÏàòÎì§ (Ïô∏Î∂ÄÏóêÏÑú ÏßÅÏ†ë Ìò∏Ï∂ú Í∞ÄÎä•) ---
export async function robotBlinkOn() {
  try {
    const robot = robotController || await initRobotController();
    if (robot) {
      await robot.setBlink(true);
      console.log('ü§ñ [Manual] Robot blink ON');
    }
  } catch (e) {
    console.warn('[Manual] robotBlinkOn failed:', e?.message || e);
  }
}

export async function robotBlinkOff() {
  try {
    const robot = robotController || await initRobotController();
    if (robot) {
      await robot.setBlink(false);
      console.log('ü§ñ [Manual] Robot blink OFF');
    }
  } catch (e) {
    console.warn('[Manual] robotBlinkOff failed:', e?.message || e);
  }
}

export async function robotToggleBlink() {
  try {
    const robot = robotController || await initRobotController();
    if (robot) {
      await robot.toggleBlink();
      console.log('ü§ñ [Manual] Robot blink toggled');
    }
  } catch (e) {
    console.warn('[Manual] robotToggleBlink failed:', e?.message || e);
  }
}

export async function getRobotStatus() {
  try {
    const robot = robotController || await initRobotController();
    if (robot) {
      const status = await robot.getStatus();
      console.log('ü§ñ [Manual] Robot status:', status);
      return status;
    }
    return null;
  } catch (e) {
    console.warn('[Manual] getRobotStatus failed:', e?.message || e);
    return null;
  }
}

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export const ttsEvents = new EventEmitter();

let speakingQueue = [];
let isSpeaking = false;

// --- Î°úÎ¥á Ïª®Ìä∏Î°§Îü¨ Ïù∏Ïä§ÌÑ¥Ïä§ Í¥ÄÎ¶¨ (speak.jsÏóêÏÑú ÏßÅÏ†ë) ---
let robotController = null;
let robotInitialized = false;

async function initRobotController() {
  if (robotInitialized) return robotController;
  
  robotInitialized = true;
  
  try {
    robotController = createRobotController({ 
      debug: true,
      timeoutMs: 600,
      retries: 1 
    });
    
    // Ìó¨Ïä§Ï≤¥ÌÅ¨Î°ú Ïó∞Í≤∞ ÌôïÏù∏
    const health = await robotController.healthCheck();
    if (health.online) {
      console.log(`ü§ñ [TTS] Robot controller connected (latency: ${health.latency}ms)`);
      return robotController;
    } else {
      console.warn(`ü§ñ [TTS] Robot controller offline: ${health.error || 'unknown error'}`);
      robotController = null;
      return null;
    }
  } catch (error) {
    console.warn(`ü§ñ [TTS] Failed to initialize robot controller:`, error.message);
    robotController = null;
    return null;
  }
}

// --- Î°úÎ¥á LED Ï†úÏñ¥ Ìï®ÏàòÎì§ ---
async function safeSpeechStart() {
  try {
    const robot = robotController || await initRobotController();
    if (robot?.onSpeechStart) {
      await robot.onSpeechStart();
      console.log(`üé§ [TTS] Speech started - robot blink ON`);
    }
  } catch (e) { 
    console.warn('[TTS] onSpeechStart failed:', e?.message || e); 
  }
}

async function safeSpeechEnd() {
  try {
    const robot = robotController || await initRobotController();
    if (robot?.onSpeechEnd) {
      await robot.onSpeechEnd();
      console.log(`üé§ [TTS] Speech ended - robot blink OFF`);
    }
  } catch (e) { 
    console.warn('[TTS] onSpeechEnd failed:', e?.message || e); 
  }
}

/**
 * Google Cloud TTS Ìï®Ïàò
 * @param {string} text - ÎßêÌï† ÌÖçÏä§Ìä∏
 * @param {string} voice - Î™©ÏÜåÎ¶¨ (ko-KR-Neural2-A, ko-KR-Neural2-B, ko-KR-Neural2-C)
 * @param {string} languageCode - Ïñ∏Ïñ¥ ÏΩîÎìú (ko-KR, en-US Îì±)
 * @returns {Promise<Buffer>} - MP3 Ïò§ÎîîÏò§ Îç∞Ïù¥ÌÑ∞
 */
async function sendGoogleTTS(text, voice = 'ko-KR-Neural2-A', languageCode = 'ko-KR') {
  try {
    const client = new textToSpeech.TextToSpeechClient();
    
    console.log(`üé§ [Google TTS] Generating speech (voice: ${voice}, language: ${languageCode})`);
    
    const request = {
      input: { text: text },
      voice: {
        languageCode: languageCode,
        name: voice,
        ssmlGender: voice.includes('-A') || voice.includes('-B') ? 'FEMALE' : 'MALE'
      },
      audioConfig: {
        audioEncoding: 'MP3',
        speakingRate: 1.0,  // ÏÜçÎèÑ (0.25 ~ 4.0)
        pitch: 0.0,         // ÏùåÎÜíÏù¥ (-20.0 ~ 20.0)
        volumeGainDb: 0.0   // Î≥ºÎ•® (-96.0 ~ 16.0)
      },
    };

    const [response] = await client.synthesizeSpeech(request);
    const audioBuffer = Buffer.from(response.audioContent);
    
    console.log(`‚úÖ [Google TTS] Generated ${audioBuffer.length} bytes`);
    return audioBuffer;
    
  } catch (err) {
    console.error('[Google TTS] Error:', err.message);
    throw err;
  }
}

/**
 * Text-to-Speech with queue.
 * Keeps API compat with previous usage but now returns a Promise that resolves when playback finishes.
 * @param {string} text
 * @param {string|object} speak_model e.g. 'google/ko-KR-Neural2-A' or 'pollinations/openai-audio/echo'
 * @returns {Promise<void>}
 */
export function say(text, speak_model) {
  return new Promise((resolve, reject) => {
    speakingQueue.push({ text, speak_model, resolve, reject });
    if (!isSpeaking) processQueue();
  });
}

async function processQueue() {
  if (speakingQueue.length === 0) {
    isSpeaking = false;
    // ‚úÖ TTS Ï¢ÖÎ£å ÏïåÎ¶º (STT Ïû¨Í∞ú Í∞ÄÎä•)
    global.isTTSPlaying = false;
    ttsEvents.emit('speaking-ended');
    return;
  }
  isSpeaking = true;
  
  // ‚úÖ TTS ÏãúÏûë ÏïåÎ¶º (STT ÏùºÏãúÏ†ïÏßÄ)
  global.isTTSPlaying = true;
  ttsEvents.emit('speaking-started');

  const job = speakingQueue.shift();
  const txt = job.text;
  const speak_model = job.speak_model;
  const resolve = job.resolve;
  const reject = job.reject;

  const isWin = process.platform === 'win32';
  const isMac = process.platform === 'darwin';
  const model = speak_model || 'google/ko-KR-Neural2-A';

  // Í≥µÌÜµ: ÏãúÏûë Ïù¥Î≤§Ìä∏/LED
  try { ttsEvents.emit('start', { text: txt, model }); } catch {}
  await safeSpeechStart();

  const finishOk = async () => {
    try { ttsEvents.emit('end', { text: txt, model }); } catch {}
    await safeSpeechEnd();
    resolve?.();
    processQueue();
  };
  const finishErr = async (err) => {
    try { ttsEvents.emit('error', err); } catch {}
    await safeSpeechEnd();
    reject?.(err);
    processQueue();
  };

  if (model === 'system') {
    // --- System TTS (Windows/macOS/Linux) ---
    const cmd = isWin
      ? `powershell -NoProfile -Command "Add-Type -AssemblyName System.Speech; `
        + `$s=New-Object System.Speech.Synthesis.SpeechSynthesizer; $s.Rate=2; `
        + `$s.Speak('${txt.replace(/'/g,"''")}'); $s.Dispose()"`
      : isMac
      ? `say "${txt.replace(/"/g,'\\"')}"`
      : `espeak "${txt.replace(/"/g,'\\"')}"`;

    exec(cmd, async (err) => {
      if (err) {
        console.error('TTS error', err);
        await finishErr(err);
      } else {
        await finishOk();
      }
    });

  } else {
    // --- Parse model string ---
    let prov, voice, languageCode, url;
    if (typeof model === "string") {
      const parts = model.split('/');
      prov = parts[0];
      voice = parts[1];
      languageCode = parts[2] || (voice ? voice.split('-').slice(0, 2).join('-') : 'ko-KR');
    } else {
      prov = model.api;
      voice = model.voice;
      languageCode = model.languageCode || 'ko-KR';
      url = model.url;
    }

    // --- Google Cloud TTS ---
    if (prov === 'google') {
      try {
        const audioBuffer = await sendGoogleTTS(txt, voice, languageCode);
        
        // ‚úÖ WindowsÎèÑ ffplay ÏÇ¨Ïö© (Îçî ÏïàÏ†ïÏ†Å)
        const tempFile = path.join(__dirname, `tts_temp_${Date.now()}.mp3`);
        
        try {
          fs.writeFileSync(tempFile, audioBuffer);
          
          const player = spawn('ffplay', [
            '-nodisp',      // Ï∞Ω Ïïà ÎùÑÏö∞Í∏∞
            '-autoexit',    // Ïû¨ÏÉù ÎÅùÎÇòÎ©¥ ÏûêÎèô Ï¢ÖÎ£å
            '-loglevel', 'quiet',  // Î°úÍ∑∏ Ïà®Í∏∞Í∏∞
            tempFile
          ], {
            stdio: 'ignore'
          });
          
          player.on('exit', async (code) => { 
            try { fs.unlinkSync(tempFile); } catch {}
            if (code === 0) await finishOk();
            else await finishErr(new Error(`ffplay exit ${code}`));
          });
          
          player.on('error', async (e) => { 
            console.error('[TTS] ffplay error:', e.message);
            try { fs.unlinkSync(tempFile); } catch {}
            await finishErr(e); 
          });
          
        } catch (e) {
          try { fs.unlinkSync(tempFile); } catch {}
          await finishErr(e);
        }

      } catch (e) {
        console.error('Google TTS error', e);
        await finishErr(e);
      }

    // --- Pollinations TTS ---
    } else if (prov === 'pollinations') {
      url = url || "https://text.pollinations.ai/openai";
      
      try {
        let audioData = await sendAudioRequest(txt, voice, null, url);
        if (!audioData) {
          audioData = "SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU5LjI3LjEwMAAAAAAAAAAAAAAA/+NAwAAAAAAAAAAAAEluZm8AAAAPAAAAAAAAANAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAExhdmM1OS4zNwAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAeowAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==";
        }

        if (isWin) {
          const ps = `
            Add-Type -AssemblyName presentationCore;
            $p=New-Object System.Windows.Media.MediaPlayer;
            $p.Open([Uri]::new("data:audio/mp3;base64,${audioData}"));
            $p.Play();
            Start-Sleep -Seconds [math]::Ceiling($p.NaturalDuration.TimeSpan.TotalSeconds);
          `;
          const psProcess = spawn('powershell', ['-NoProfile','-Command', ps], {
            stdio: 'ignore', detached: true
          });
          psProcess.on('exit', async () => { await finishOk(); });

        } else {
          const player = spawn('ffplay', ['-nodisp','-autoexit','pipe:0'], {
            stdio: ['pipe','ignore','ignore']
          });
          player.stdin.write(Buffer.from(audioData, 'base64'));
          player.stdin.end();
          player.on('exit', async (code) => { 
            if (code === 0) await finishOk(); 
            else await finishErr(new Error(`ffplay exit ${code}`));
          });
          player.on('error', async (e) => { 
            console.error('ffplay spawn error', e); 
            await finishErr(e); 
          });
        }

      } catch (e) {
        console.error('Pollinations TTS error', e);
        await finishErr(e);
      }

    } else {
      await finishErr(new Error(`Unknown TTS provider: ${prov}`));
    }
  }
}

// --- ÏàòÎèô Î°úÎ¥á Ï†úÏñ¥ Ìï®ÏàòÎì§ (Ïô∏Î∂ÄÏóêÏÑú ÏßÅÏ†ë Ìò∏Ï∂ú Í∞ÄÎä•) ---
export async function robotBlinkOn() {
  try {
    const robot = robotController || await initRobotController();
    if (robot) {
      await robot.setBlink(true);
      console.log('ü§ñ [Manual] Robot blink ON');
    }
  } catch (e) {
    console.warn('[Manual] robotBlinkOn failed:', e?.message || e);
  }
}

export async function robotBlinkOff() {
  try {
    const robot = robotController || await initRobotController();
    if (robot) {
      await robot.setBlink(false);
      console.log('ü§ñ [Manual] Robot blink OFF');
    }
  } catch (e) {
    console.warn('[Manual] robotBlinkOff failed:', e?.message || e);
  }
}

export async function robotToggleBlink() {
  try {
    const robot = robotController || await initRobotController();
    if (robot) {
      await robot.toggleBlink();
      console.log('ü§ñ [Manual] Robot blink toggled');
    }
  } catch (e) {
    console.warn('[Manual] robotToggleBlink failed:', e?.message || e);
  }
}

export async function getRobotStatus() {
  try {
    const robot = robotController || await initRobotController();
    if (robot) {
      const status = await robot.getStatus();
      console.log('ü§ñ [Manual] Robot status:', status);
      return status;
    }
    return null;
  } catch (e) {
    console.warn('[Manual] getRobotStatus failed:', e?.message || e);
    return null;
  }
}
